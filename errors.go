package rtm2

import (
	"fmt"
)

type RTMError struct {
	msg   string
	errno int
}

func (e RTMError) Error() string {
	return fmt.Sprintf("%d: %s", e.errno, e.msg)
}

func newRTMError(errno int, msg string) error {
	return RTMError{errno: errno, msg: msg}
}

var (
	ERR_TOPIC_ALREADY_JOINED                    = newRTMError(10001, "ERR_TOPIC_ALREADY_JOINED")
	ERR_EXCEED_JOIN_TOPIC_LIMITATION            = newRTMError(10002, "ERR_EXCEED_JOIN_TOPIC_LIMITATION")
	ERR_INVALID_TOPIC_NAME                      = newRTMError(10003, "ERR_INVALID_TOPIC_NAME")
	ERR_PUBLISH_TOPIC_MESSAGE_FAILED            = newRTMError(10004, "ERR_PUBLISH_TOPIC_MESSAGE_FAILED")
	ERR_EXCEED_SUBSCRIBE_TOPIC_LIMITATION       = newRTMError(10005, "ERR_EXCEED_SUBSCRIBE_TOPIC_LIMITATION")
	ERR_EXCEED_USER_LIMITATION                  = newRTMError(10006, "ERR_EXCEED_USER_LIMITATION")
	ERR_EXCEED_CHANNEL_LIMITATION               = newRTMError(10007, "ERR_EXCEED_CHANNEL_LIMITATION")
	ERR_ALREADY_JOIN_CHANNEL                    = newRTMError(10008, "ERR_ALREADY_JOIN_CHANNEL")
	ERR_NOT_JOIN_CHANNEL                        = newRTMError(10009, "ERR_NOT_JOIN_CHANNEL")
	ERR_ALREADY_LOGIN                           = newRTMError(10010, "ERR_ALREADY_LOGIN")
	ERR_NOT_LOGIN                               = newRTMError(10011, "ERR_NOT_LOGIN")
	ERR_DUPLICATE_TOKEN                         = newRTMError(10012, "ERR_DUPLICATE_TOKEN")
	ERR_NOT_SUBSCRIBED                          = newRTMError(10013, "ERR_NOT_SUBSCRIBED")
	ERR_ALREADY_SUBSCRIBED                      = newRTMError(10014, "ERR_ALREADY_SUBSCRIBED")
	ERR_ENCRYPTION_FAILED                       = newRTMError(10015, "ERR_ENCRYPTION_FAILED")
	ERR_METADATA_SIZE_OVERFLOW                  = newRTMError(10101, "ERR_METADATA_SIZE_OVERFLOW")
	ERR_METADATA_ITEM_SIZE_OVERFLOW             = newRTMError(10102, "ERR_METADATA_ITEM_SIZE_OVERFLOW")
	ERR_METADATA_KEY_SIZE_OVERFLOW              = newRTMError(10103, "ERR_METADATA_KEY_SIZE_OVERFLOW")
	ERR_METADATA_VALUE_SIZE_OVERFLOW            = newRTMError(10104, "ERR_METADATA_VALUE_SIZE_OVERFLOW")
	ERR_METADATA_INVALID_KEY                    = newRTMError(10105, "ERR_METADATA_INVALID_KEY")
	ERR_METADATA_INVALID_REVISION               = newRTMError(10106, "ERR_METADATA_INVALID_REVISION")
	ERR_METADATA_NOT_SUBSCRIBED                 = newRTMError(10107, "ERR_METADATA_NOT_SUBSCRIBED ")
	ERR_METADATA_ALREADY_SUBSCRIBED             = newRTMError(10108, "ERR_METADATA_ALREADY_SUBSCRIBED")
	ERR_METADATA_EXCEED_SUBSCRIPTION_LIMIT      = newRTMError(10109, "ERR_METADATA_EXCEED_SUBSCRIPTION_LIMIT")
	ERR_METADATA_WITH_INVALID_LOCK              = newRTMError(10110, "ERR_METADATA_WITH_INVALID_LOCK")
	ERR_LOCK_OPERATION_PERFORMING               = newRTMError(10201, "ERR_LOCK_OPERATION_PERFORMING")
	ERR_RELEASE_LOCK_NOT_ACQUIRED               = newRTMError(10202, "ERR_RELEASE_LOCK_NOT_ACQUIRED")
	ERR_PRESENCE_SERVICE_NOT_READY              = newRTMError(10301, "ERR_PRESENCE_SERVICE_NOT_READY")
	ERR_PRESENCE_OPERATION_WITHOUT_JOIN_CHANNEL = newRTMError(10302, "ERR_PRESENCE_OPERATION_WITHOUT_JOIN_CHANNEL")
	ERR_PRESENCE_STATE_SIZE_OVERFLOW            = newRTMError(10303, "ERR_PRESENCE_STATE_SIZE_OVERFLOW")
	ERR_PRESENCE_STATE_KEY_SIZE_OVERFLOW        = newRTMError(10304, "ERR_PRESENCE_STATE_KEY_SIZE_OVERFLOW")
	ERR_PRESENCE_STATE_INVALID_KEY              = newRTMError(10305, "ERR_PRESENCE_STATE_INVALID_KEY")
	ERR_PRESENCE_STATE_DUPLICATE_KEY            = newRTMError(10306, "ERR_PRESENCE_STATE_DUPLICATE_KEY")
	ERR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW      = newRTMError(10307, "ERR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW")
	ERR_PRESENCE_SYNC_CLIENT_ERROR              = newRTMError(10308, "ERR_PRESENCE_SYNC_CLIENT_ERROR")
	ERR_PRESENCE_USER_NOT_EXIST                 = newRTMError(10309, "ERR_PRESENCE_USER_NOT_EXIST")
	ERR_PRESENCE_CHANNEL_COUNT_OVERFLOW         = newRTMError(10310, "ERR_PRESENCE_CHANNEL_COUNT_OVERFLOW")
	ERR_PRESENCE_CHANNEL_NOT_EXIST              = newRTMError(10311, "ERR_PRESENCE_CHANNEL_NOT_EXIST")
)

func ErrorFromCode(errno int32) error {
	if errno == 0 {
		return nil
	}
	switch errno {
	case 10001:
		return ERR_TOPIC_ALREADY_JOINED
	case 10002:
		return ERR_EXCEED_JOIN_TOPIC_LIMITATION
	case 10003:
		return ERR_INVALID_TOPIC_NAME
	case 10004:
		return ERR_PUBLISH_TOPIC_MESSAGE_FAILED
	case 10005:
		return ERR_EXCEED_SUBSCRIBE_TOPIC_LIMITATION
	case 10006:
		return ERR_EXCEED_USER_LIMITATION
	case 10007:
		return ERR_EXCEED_CHANNEL_LIMITATION
	case 10008:
		return ERR_ALREADY_JOIN_CHANNEL
	case 10009:
		return ERR_NOT_JOIN_CHANNEL
	case 10010:
		return ERR_ALREADY_LOGIN
	case 10011:
		return ERR_NOT_LOGIN
	case 10012:
		return ERR_DUPLICATE_TOKEN
	case 10013:
		return ERR_NOT_SUBSCRIBED
	case 10014:
		return ERR_ALREADY_SUBSCRIBED
	case 10015:
		return ERR_ENCRYPTION_FAILED
	case 10101:
		return ERR_METADATA_SIZE_OVERFLOW
	case 10102:
		return ERR_METADATA_ITEM_SIZE_OVERFLOW
	case 10103:
		return ERR_METADATA_KEY_SIZE_OVERFLOW
	case 10104:
		return ERR_METADATA_VALUE_SIZE_OVERFLOW
	case 10105:
		return ERR_METADATA_INVALID_KEY
	case 10106:
		return ERR_METADATA_INVALID_REVISION
	case 10107:
		return ERR_METADATA_NOT_SUBSCRIBED
	case 10108:
		return ERR_METADATA_ALREADY_SUBSCRIBED
	case 10109:
		return ERR_METADATA_EXCEED_SUBSCRIPTION_LIMIT
	case 10110:
		return ERR_METADATA_WITH_INVALID_LOCK
	case 10201:
		return ERR_LOCK_OPERATION_PERFORMING
	case 10202:
		return ERR_RELEASE_LOCK_NOT_ACQUIRED
	case 10301:
		return ERR_PRESENCE_SERVICE_NOT_READY
	case 10302:
		return ERR_PRESENCE_OPERATION_WITHOUT_JOIN_CHANNEL
	case 10303:
		return ERR_PRESENCE_STATE_SIZE_OVERFLOW
	case 10304:
		return ERR_PRESENCE_STATE_KEY_SIZE_OVERFLOW
	case 10305:
		return ERR_PRESENCE_STATE_INVALID_KEY
	case 10306:
		return ERR_PRESENCE_STATE_DUPLICATE_KEY
	case 10307:
		return ERR_PRESENCE_STATE_VALUE_SIZE_OVERFLOW
	case 10308:
		return ERR_PRESENCE_SYNC_CLIENT_ERROR
	case 10309:
		return ERR_PRESENCE_USER_NOT_EXIST
	case 10310:
		return ERR_PRESENCE_CHANNEL_COUNT_OVERFLOW
	case 10311:
		return ERR_PRESENCE_CHANNEL_NOT_EXIST
	default:
		return newRTMError(int(errno), "UNKNOWN ERROR")
	}
}
